<?php
/**
 *
 * This file is part of Documents.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * @copyright   Copyright (C) Damien Carcel (https://github.com/damien-carcel)
 * @link        https://github.com/damien-carcel/Documents
 * @license     http://www.gnu.org/licenses/gpl.html
 */

namespace Carcel\DocumentsBundle\Entity;

use Doctrine\ORM\EntityRepository;

/**
 * FolderRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class FolderRepository extends EntityRepository
{
    /**
     * Return a folder with all the files it contains.
     *
     * @param int $folderId The Id of the folder we want to get.
     * @return mixed
     */
    public function getWithFiles($folderId)
    {
        $query = $this->createQueryBuilder('dir')
            ->leftJoin('dir.files', 'f')
                ->addSelect('f')
                ->orderBy('f.name')
            ->where('dir.id = :id')
            ->setParameter('id', $folderId)
            ->getQuery();

        return $query->getOneOrNullResult();
    }

    /**
     * Return a hierarchic, well formatted list of all folders destined
     * to pick up a new parent folder for a file or a folder to move.
     *
     * @param Folder $folder The folder that contain the element we
     * want to move.
     * @param File $file The file we want to move. The parameter is
     * null if we want to move a folder.
     * @return array
     */
    public function getMoveList(Folder $folder, File $file = null)
    {
        // Retrieve root folder for a start and set the temporary name
        $root = $this->createQueryBuilder('dir')->where('dir.id = 0')
            ->getQuery()->getResult();
        $root[0]->setTempName($root[0]->getName());

        // Create the hierarchic list of folders
        $level = '└';
        $root = $this->createDirList($root, 0, $level, $folder, $file);

        if ((!is_null($file) and $folder->getId() == 0)
            or (is_null($file) and $folder->getParent()->getId() == 0)) {
            unset($root[0]);
        }

        return $root;
    }

    /**
     * Create a hierarchic, well formatted list of all folders present
     * in database, minus the parent of the element we want to move,
     * and if it is a folder the element itself and its children.
     *
     * @param array $root The list of folder, which only contain the
     * root folder at the start.
     * @param int $parentId The ID of the folder we want to retrieve
     * all children
     * @param string $level A graphical representation of the folders
     * hierarchy.
     * @param Folder $folder The folder that contain the element we
     * want to move.
     * @param File $file The file we want to move. The parameter is
     * null if we want to move a folder.
     * @return array
     */
    private function createDirList($root, $parentId, $level, Folder $folder, File $file = null)
    {
        // We retrieve only the folders contained by the one which has $parentId as ID
        $folders = $this->createQueryBuilder('dir')
            ->where('dir.parent = :parent_id')
            ->setParameter('parent_id', $parentId)
            ->getQuery()->getResult();

        // Sort the folders hierarchically
        foreach ($folders as $dir) {
            // If we move a folder, then it and its children does not show on the list
            if (is_null($file) and $folder->getId() == $dir->getId()) {
                continue;
            } else {
                $newLevel = $level . '–––';

                $dir->setTempName($level . '→' . $dir->getName());
                // We had the recently renamed folder on the list
                $root[] = $dir;

                // Then we retrieve the folders it contains and start again by making the method calling itself
                $root = $this->createDirList($root, $dir->getId(), $newLevel, $folder, $file);
            }
        }

        return $root;
    }
}
